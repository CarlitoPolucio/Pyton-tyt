## Частично об операторе `*`
```python
# Математические операции:
2 * 3    # Умножение → 6
3 ** 2   # Возведение в степень → 9

# Повторение последовательностей:
[0] * 3       # → [0, 0, 0]
"ab" * 2      # → "abab"
(1, 2) * 2    # → (1, 2, 1, 2)

# Распаковка (Unpacking):
numbers = [1, 2, 3]
print(*numbers)  # Эквивалент print(1, 2, 3)

first, *middle, last = [1, 2, 3, 4, 5]
# first = 1, middle = [2, 3, 4], last = 5

# Объединение коллекций:
list1 = [1, 2]
list2 = [*list1, 3, 4]  # → [1, 2, 3, 4]
```

## Iterable, iterator(базовые сведения)
Итерируемый - такой объект, который можно перебирать в цикле for. Он возвращает элементы по одному при итерации.
- Списки ([1, 2, 3])
- Строки ("hello")
- Словари ({"a": 1, "b": 2})
- Множества ({1, 2, 3})
- ...

Итератор - объект, который выдает элементы по одному при каждом запросе.

### Сравнение итерируемых объектов и итераторов в Python

| Характеристика       | Итерируемый объект          | Итератор                     |
|----------------------|-----------------------------|------------------------------|
| **Перебор**          | Можно перебирать многократно | Одноразовый (после завершения нужно создавать заново) |
| **Использование**    | Хранит данные               | Выдает элементы по одному    |
| **Примеры**         | Список, строка, словарь     | `iter(list)`, генераторы     |

## tuple

### Создание кортежа
```python
empty_tuple = ()
single_item = 42,  # Без запятой это число, а не кортеж!

# Преобразование
my_list = [1, 2, 3]
my_tuple = tuple(my_list)  # (1, 2, 3)
```

### Основные операции
```python
# Обращение по индексу:
fruits = ("apple", "banana", "cherry")
print(fruits[1])  # banana

# Срезы:
print(fruits[0:2])  # ("apple", "banana")

# Конкатенация:
new_tuple = (1, 2) + (3, 4)  # (1, 2, 3, 4)

# умножение:
repeated = ("Hi",) * 3  # ("Hi", "Hi", "Hi")

# распаковка:
point = (10, 20)
x, y = point  # x = 10, y = 20
a, _, b = (1, 2, 3)  # a = 1, b = 3

def get_user():
    return ("John", 30, "john@example.com")

name, age, email = get_user()

# кортежи сравниваются поэлементно:
print((1, 2) < (1, 3))  # True (2 < 3)
print((1, 2) == (1, 2))  # True
```

### Неизменяемость
```python
fruits = ("apple", "banana", "cherry")

fruits[0] = "orange"  # Ошибка: TypeError

# Но если элемент кортежа — изменяемый объект (например, список), его содержимое можно менять:
mixed = (1, [2, 3], 4)
mixed[1][0] = 99  # Кортеж станет (1, [99, 3], 4)
```

### Примечания

- кортежи занимают меньше места, чем списки.
- кортежи могут быть ключами словарей.
- ![](https://cs13.pikabu.ru/post_img/2023/06/13/1/1686609733126038067.jpg)


## zip
Функция zip() используется для параллельной итерации по нескольким итерируемым объектам (спискам, кортежам и т.д.), объединяя их элементы в кортежи.

### Синтаксис:
```text
zip(*iterables, strict=False)
```

### Свойства
- Возвращает итератор из кортежей, где каждый кортеж содержит i-е элементы всех переданных коллекций.
- Длина результирующего итератора равна длине самой короткой коллекции (если strict=False).

### Примеры
```python
#  Объединение списков:
names = ["Alice", "Bob", "Charlie"]
ages = [25, 30, 35]

zipped = zip(names, ages)
print(list(zipped))  
# [('Alice', 25), ('Bob', 30), ('Charlie', 35)]

# Итерация по нескольким коллекциям
for name, age in zipped:
    print(f"{name} is {age} years old")
# Alice is 25 years old
# Bob is 30 years old
# Charlie is 35 years old

# Создание словаря:
dict_from_zip = dict(zipped)
print(dict_from_zip)
# {'Alice': 25, 'Bob': 30, 'Charlie': 35}

# Обратна операция:
zipped = [('a', 1), ('b', 2)]
names, nums = zip(*zipped)
print(names)  # ('a', 'b')
print(nums)   # (1, 2)

# Аналог:
min_len = min(len(names), len(ages))
result = [(names[i], ages[i]) for i in range(min_len)]
```

## Хеширование
Простота кортежей, с одной стороны, даёт преимущества (кортежи занимают мало памяти), но с другой — у неё есть и недостатки.
Например, если мы захотим проверить, есть ли какой-то объект внутри кортежа, Python пройдёт по всем объектам, сравнивая их с целевым. Соответственно, в худшем случае сложность такой операции будет равна О(n).
При этом у словарей и множеств такая операция будет иметь сложность О(1). Выходит, сколько бы элементов ни добавляли в словарь, время поиска ключа почти не будет увеличиваться. В чём магия? Чтобы в этом разобраться, нужно познакомиться с тремя понятиями:

- хеш;
- хеш-функция;
- хеш-таблица.

Хеш, или хеш-значение, — результат применения хеш-функции к каким-либо данным (в нашем случае к неизменяемым). Это число фиксированной длины, служащее «подписью» для входных данных, к которым применена хеш-функция. 

Хеш-функция — функция, которая преобразует входные данные произвольной длины в выходное хеш-значение фиксированной длины. Грубо говоря, хеш-функция кодирует (шифрует) данные.

В Python встроена реализация хеш-функции — hash. Попробуем её использовать:
```python
tuple = (1, 2, 3) # Есть неизменяемый объект (кстати, попробуйте потом повторить этот код с изменяемым объектом)
hash_value = hash(tuple) # Применим к этому объекту функцию hash
print(hash_value) # Проверим, что получилось (бессмысленный набор чисел)
hash_value_2 = hash(tuple) # Попробуем ещё раз
print(hash_value_2) # Опять набор чисел
print(hash_value == hash_value_2) # И он в точности равен первому
```

В идеале при работе с одинаковыми объектами получаются одинаковые хеш-значения, а с разными объектами — разные хеш-значения. Но иногда бывают коллизии: два разных объекта возвращают одно и то же хеш-значение. 

Чем лучше реализована хеш-функция, тем меньше с ней возникает коллизий.

При желании вы можете сами реализовать такую хеш-функцию. Один из самых простых примеров:

```python
def simple_hash(input_string): # На вход получаем строку
    hash_value = 0
    for char in input_string: # Запускаем цикл по символам строки
        hash_value += ord(char) # Суммируем код каждого символа
    return hash_value # На выходе получаем сумму — некое числовое значение
```


Эта хеш-функция будет не очень хорошей, так как разные символы часто будут совпадать по суммам и приводить к коллизиям. При этом вы вольны добавлять любые преобразования. Главное, чтобы на выходе у вас получилось число (в некоторых случаях существует ещё требование к количеству цифр в числе).

Зная, что такое хеш-значение и как его получать, подумаем, как его применять.

Хеш-таблица — структура данных, используемая для реализации ассоциативного массива или словаря. Позволяет эффективно хранить пары «ключ — значение» и обеспечивает быстрый доступ к значениям по ключу.

Самостоятельно такую таблицу вы, возможно, никогда не создавали, но каждый раз, когда вы использовали словарь, она создавалась автоматически.

Основная идея хеш-таблицы — в том, чтобы преобразовать ключи в хеш-значения с помощью хеш-функции. Хеш-функция принимает на вход ключ и возвращает числовое значение, которое потом используется для определения индекса во внутреннем массиве хеш-таблицы. После пара «ключ — значение» сохраняется в соответствующей корзине.

Другими словами, когда вы создаёте словарь (или множество), Python создаёт список, в котором индексы — это хеш-значения, а значения — это ваши данные («ключ — значение» — для словаря; значение — для множества).

```python
tuple = (1, 2, 3) # Возьмём тот же кортеж
print(hash(tuple)) # Его хеш при каждом запуске может отличаться
# При моём запуске хеш был равен числу 529344067295497451
hash_dict = {(1, 2, 3): 'hello'} # Если я захочу создать словарь с этим кортежем,
# то «под капотом» будет создан массив, в котором по индексу 529344067295497451 
# будет храниться пара (1, 2, 3) и 'hello'
```

Такой массив будет отличаться от привычного списка. В нём не обязательно будут индексы от 0 до 529344067295497451, но если мы возьмём этот массив и используем индекс 529344067295497451, то он вернёт пару «ключ — значение»: (1, 2, 3), 'hello'

Что это даёт? Когда мы захотим проверить, есть ли ключ в словаре, Python вместо перебора всех ключей возьмёт хеш искомого объекта и проверит, существует ли по такому индексу элемент в его хеш-таблице. 

Если элемент есть, мы сможем, например, получить значение по этому ключу. Если элемента нет, то и искать его в других местах не придётся: если бы он был, он бы вернул точно такой же хеш и лежал бы именно на этом месте.

Вот и вся магия.

Поговорим ещё немного о недостатках (коллизиях).

Для коллизий — ситуаций, где двум ключам соответствует одно хеш-значение, — в хеш-таблице предусмотрен механизм решения.

Одно из распространённых решений — использование списков (цепочек): для каждого ключа хранится список пар «ключ — значение». При коллизии новая пара добавляется в список соответствующего ключа.

То есть все элементы, которые по ошибке получили одинаковые хеши, будут храниться в отдельном списке, а уже из списка их можно будет получать обычным перебором.

![](https://api.selcdn.ru/v1/SEL_72086/prodLMS/files/share/image1_oECesf0.jpg)

Стоит сделать важный вывод: нет универсальной структуры данных, но для разных задач есть наиболее подходящие структуры и важно уметь правильно выбирать их. Если в приоритете скорость поиска — словарь будет лучше кортежа. Если важна компактность хранения данных — кортеж будет выгоднее.

### Алгоритм Рабина — Карпа
Алгоритм поиска подстроки с использованием хеш-таблицы (алгоритм Рабина — Карпа) состоит из следующих шагов:

- Вычисление хеш-значения искомой подстроки.
- Прохождение по тексту с помощью скользящего окна, равного по размеру подстроке, для вычисления хеш-значения каждого окна.
- Если хеш-значение окна совпадает с хеш-значением подстроки, каждый символ окна сравнивается с символами подстроки, чтобы убедиться в совпадении.
- Если символы совпадают, подстрока найдена. Если нет — нужно продолжить проверять следующие окна.

Звучит, возможно, не слишком просто, но вы уже рассматривали похожий алгоритм, когда выполняли поиск при помощи цикла и вложенного цикла. 

Циклом мы проходили по символам строки, а вложенным циклом проверяли, что подстрока, которая начинается с текущего символа, равна подстроке, которую ищем.

Сложность алгоритма с циклами была:

O(main_length * sub_length), где main_length — длина строки, а sub_length — длина подстроки.

Алгоритм Рабина — Карпа использует ту же основу, но вместо сравнения двух строк по символам выполняется сравнение по хеш-значениям.

Алгоритм может иметь среднюю сложность: O(n + m), где n — длина текста, а m — длина подстроки. 

Однако сложность может достигать O(n * m), если все хеш-значения окон совпадут с хеш-значением подстроки, требуя полной проверки каждого символа. То есть в худшем случае алгоритм будет равен по сложности алгоритму с вложенным циклом, который мы рассматривали ранее, а в среднем будет гораздо быстрее.

Важно отметить, что при использовании хеш-таблицы для поиска подстроки может возникнуть коллизия хешей, и в этом случае потребуется дополнительная проверка символов, чтобы избежать ложных срабатываний. 

Также при использовании хеш-таблицы нужна предварительная обработка текста и подстроки для эффективного вычисления хеш-значений.

```python
def rabin_karp_search(text, pattern):
    # Проверяем случаи, когда текст или подстрока пустые
    if not text or not pattern:
        return []

    # Вычисляем хеш-значение для подстроки и первого окна текста
    pattern_hash = hash(pattern)
    window_hash = hash(text[:len(pattern)])

    matches = [] # Список индексов совпадений

    # Проходим по тексту с помощью скользящего окна
    for i in range(len(text) - len(pattern) + 1):
        # Если хеш-значения совпадают, сравниваем каждый символ окна с подстрокой
        if pattern_hash == window_hash and text[i:i + len(pattern)] == pattern:
            # Стоит уточнить, что благодаря ленивому выполнению Python, если первое условие в связке AND вернёт False, то второе не будет запускаться вообще
            matches.append(i)

        # Обновляем хеш-значение для следующего окна
        window_hash = hash(text[i + 1:i + len(pattern) + 1])

    return matches

# Пример использования
text = "abracadabra"
pattern = "cad"
matches = rabin_karp_search(text, pattern)
print(f"Совпадения найдены на позициях: {matches}")
```

В этом примере функция rabin_karp_search принимает текст и подстроку в качестве аргументов и возвращает список индексов, где найдены совпадения. Если совпадений нет, возвращается пустой список.

Обратите внимание: хеш-значения вычисляются с использованием встроенной функции hash(), которая генерирует хеш-код для объекта. В реальных ситуациях можно использовать более сложные алгоритмы хеширования для получения наиболее сбалансированной вероятности получения каждого возможного хеш-кода и снижения вероятности коллизий.

Стоит также отметить, что рассмотренный код реализует простейший вариант алгоритма Рабина — Карпа и его можно улучшить для более эффективной обработки коллизий и предварительной обработки текста и подстроки.