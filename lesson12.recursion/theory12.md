## Рекурсия

Рекурсия - это процесс, в котором функция вызывает саму себя непосредственно или косвенно. 

Рекурсивная функция обычно состоит из двух частей:
- Базовый случай (условие выхода) — предотвращает бесконечную рекурсию.
- Рекурсивный случай — вызов функции с изменёнными аргументами, приближающими к базовому случаю.

Каждый рекурсивный вызов добавляет в стек новый фрейм (кадр) с:
- аргументами функции
- локальными переменными
- точкой возврата

При достижении базового случая стек начинает "схлопываться" по принципу LIFO(Last In, First Out):
- Последний вызов завершается первым.
- Результаты передаются в предыдущий фрейм.

```python
def factorial(n):
    if n == 0:  # Базовый случай
        return 1
    else:       # Рекурсивный случай
        return n * factorial(n - 1)
```

| Вызов         | Возвращаемое значение       | Состояние стека                          |
|---------------|-----------------------------|------------------------------------------|
| `factorial(3)`| `3 * factorial(2)`          | `[factorial(3)]`                         |
| `factorial(2)`| `2 * factorial(1)`          | `[factorial(3), factorial(2)]`           |
| `factorial(1)`| `1 * factorial(0)`          | `[factorial(3), factorial(2), factorial(1)]` |
| `factorial(0)`| `1` (базовый случай)        | Стек начинает схлопываться               |
| `factorial(1)`| `1 * 1 = 1`                 | `[factorial(3), factorial(2)]`           |
| `factorial(2)`| `2 * 1 = 2`                 | `[factorial(3)]`                         |
| `factorial(3)`| `3 * 2 = 6`                 | Стек пуст, возврат `6`                   |

### Типы рекурсий в python
- Прямая рекурсия(Функция вызывает саму себя напрямую.)
```python
def countdown(n):
    if n == 0:
        print("Пуск!")
    else:
        print(n)
        countdown(n - 1)  # Прямой вызов
```
- Косвенная рекурсия(Функция A вызывает B, а B вызывает A)
```python
def is_even(n):
    if n == 0:
        return True
    else:
        return is_odd(n - 1)

def is_odd(n):
    return not is_even(n)
```

### Ограничение глубины
По умолчанию глубина рекурсии ~1000
```python
import sys
sys.setrecursionlimit(5000)  # Увеличиваем лимит
```
Таким образом можно легко забить всю оперативную память стеком вызовов

## Аргументы функций в Python

- Виды:
  - Позиционные
      - Передаются в порядке объявления параметров функции.
      - Обязательны при передаче, если не имеют значения по умолчанию.
  - Именованные(keyword)
      - Передаются явно с указанием имени параметра.
      - Порядок не важен.
      - Не обязательны для передачи, если объявлены в функции

```python

def greet(name, message="Hello"): # name позиционное объявление; message="Hello" именованное объявление/параметр по умолчанию
    print(f"{message}, {name}!")

# Позиционная передача
greet("Анна", "Привет")  # Порядок важен!
# Именованная передача
greet(message="Здравствуй", name="Пётр")  # Порядок неважен
```

## type; id; isinstance
type - возвращает тип объекта
```python
num = 42
print(type(num))  # <class 'int'>
```

id - возвращает уникальный идентификатор объекта (адрес в памяти)
```python
a = [1, 2]
b = a
print(id(a) == id(b))  # True (это один и тот же список)
```

isinstance - проверяет, относится ли объект к указанному типу данных.
```python
isinstance(5, int)           # True (5 — целое число)
isinstance("Hi", str)        # True ("Hi" — строка)
isinstance([1, 2], list)     # True ([1, 2] — список)
isinstance(3.14, (int, float)) # True (3.14 — float, входит в кортеж типов)
```

## args kwargs

*args — позиционные аргументы
- Собирает все лишние позиционные аргументы в кортеж.
- Имя args — соглашение, можно любое.
```python
def sum_numbers(*numbers):
    return sum(numbers)

print(sum_numbers(1, 2, 3))  # 6
```

**kwargs — именованные аргументы
- Собирает все лишние именованные аргументы в словарь.
- Имя kwargs — соглашение.
```python
def print_info(**info):
    for key, value in info.items():
        print(f"{key}: {value}")

print_info(name="Анна", age=25)
# Вывод:
# name: Анна
# age: 25

# Быстрая распаковка словаря в качестве именованной передачи аргументов
info = {"name": "Анна", "age": 25}
print_info(**info)  # Эквивалентно print_info(name="Анна", age=25)
```
### Порядок параметров
1. Позиционные (без значения по умолчанию)
2. Позиционные с дефолтом
3. *args
4. Именованные с дефолтом
5. **kwargs

```python
def func(a, b=2, *args, c=3, **kwargs):
    print(a, b, args, c, kwargs)

func(1, 4, 5, 6, c=7, d=8)
# Вывод: 1 4 (5, 6) 7 {'d': 8}

# Итоговый шаблон
def example(req1, req2, opt1=1, opt2=2, *args, **kwargs):
    """Описание функции"""
    # Тело функции
```

## call by assignment

Python использует передачу по присваиванию (call by assignment):
- Неизменяемые объекты передаются как копии (функция не может изменить оригинал).
- Изменяемые объекты передаются как ссылки (функция может изменить оригинал).

```python
def change_num(x):
    x += 10
    print("Inside:", x)  # 15

num = 5
change_num(num)
print("Outside:", num)  # 5 (не изменился)
# В функцию передаётся копия числа.
# Изменения внутри функции не влияют на оригинал.
```

```python
def append_to_list(lst):
    lst.append(4)
    print("Inside:", lst)  # [1, 2, 3, 4]

my_list = [1, 2, 3]
append_to_list(my_list)
print("Outside:", my_list)  # [1, 2, 3, 4] (изменился!)
# В функцию передаётся ссылка на список.
# Изменения внутри функции влияют на оригинал.
```

```python
def add_item(item, lst=[]):  # Один и тот же список при каждом вызове!
    lst.append(item)
    return lst

print(add_item(1))  # [1]
print(add_item(2))  # [1, 2] (неожиданно!)
```

Объявление изменяемых типов в качестве именованных аргументов **плохая практика**


## variables
![](https://api.selcdn.ru/v1/SEL_72086/prodLMS/files/share/image_1.png)

Если мы напишем 
x = 5
и 
y = x,
то и х и y будут хранить адрес ячейки памяти №123, и, только пройдя по этой ссылке,  Python сможет узнать информацию о типе объекта и его содержании.

Так, например, происходит, когда мы пытаемся выполнить над переменной действие, которое нельзя выполнить с объектом, на который ссылается переменная.

Например, нельзя вызвать число как функцию:
x = 5
x() — Python даст выполнить эту строку.
TypeError: 'int' object is not callable — но при выполнении вызовет ошибку.

Кстати, если мы изменим переменную x после этого:
x = 10,
то переменная y продолжит ссылаться на число 5,
а переменная x будет ссылаться на число 10,
то есть, когда мы пишем y = x, это значит, что мы добавляем в переменную y такую же ссылку, какая была в переменной x.
Но дальше эти переменные не будут зависеть друг от друга.

Из этого всего стоит запомнить три понятия:
- переменная — по сути, это имя,
- объекты — это области памяти для хранения значений,
- ссылки — указатели от имени к области памяти.

## Работа с объектами
L1 = [22, 33, 44]

L1 будет именем, которое содержит указатель на область памяти со списком,
но числа внутри списка — это тоже отдельные объекты, которые хранятся в своих ячейках
![](https://api.selcdn.ru/v1/SEL_72086/prodLMS/files/share/image_2.png)

Если мы напишем
L2 = L1,
то создадим ещё одно имя, которое будет ссылаться на этот же список.

![](https://api.selcdn.ru/v1/SEL_72086/prodLMS/files/share/image_3.png)

Если мы напишем
L1[0] = 55,
то, по сути, мы изменим ссылку на объект, который был внутри списка на первом месте.

![](https://api.selcdn.ru/v1/SEL_72086/prodLMS/files/share/image_4.png)

Если мы проверим после этого, что хранится в L2, то увидим те же самые числа:
[55, 33, 44],
так как L1[0] = 55 изменило не сам список, а объект внутри списка.

Такое поведение характерно для изменяемых объектов вроде списков или словарей. Это их особенность, которой можно и нужно пользоваться. Но правильно её использовать можно, только если вы знаете, как оно работает изнутри.


list_of_lists = [[1, 2, 3], 4, [5, 6, 7]]
![](https://api.selcdn.ru/v1/SEL_72086/prodLMS/files/share/image_5.png)

list_of_lists будет ссылаться на оригинал, у которого внутри есть ссылки на три любых объекта.

Первая ссылка будет ссылаться на другой список, у которого внутри тоже лежат три ссылки, которые, в свою очередь, ведут к числам 1, 2 и 3.

Вторая ссылка ведёт к числу 4.

Третья ссылка ведёт к списку с тремя ссылками внутри, а они ведут к числам 5, 6, 7.

Обращение к элементам.
По сути, нам надо выстраивать цепочку из ссылок:
list_of_lists[0] — ссылка на первую ссылку внутри списка.
list_of_lists[0][0] — ссылка на число внутри списка, который лежит внутри оригинального списка.

Если мы напишем
list_of_lists[0][0] = 10,
то эти изменения будут отражены в каждом объекте, который ссылался на список внутри list_of_lists.

С текущим примером всё легко, но это также значит, что вложенный список может быть и в других списках.

Например, мы можем вынести один простой список в переменную:

x = [1, 2, 3].

list_of_lists = [x, 4, [5, 6, 7]] — а дальше добавлять его в другие списки через переменную.

list_of_lists_2 = [x, [8], [9, 10, 11]]

list_of_lists[0][0] = 10 — изменив элемент в этом списке:

print(x, list_of_lists_2, list_of_lists, sep='\n'), мы увидим, что это изменение коснулось и x, и list_of_lists_2.

Похожая особенность касается и копирования.
Сперва давайте определимся с тем, что такое копирование — copy().
По сути, это создание объекта с теми же вложенными объектами.

В Python copy() буквально копирует объект, и, если в объекте есть ссылки, они тоже копируются.

list_of_lists = [[1, 2, 3], 4, [5, 6, 7]]
list_of_lists_2 = list_of_lists.copy()
![](https://api.selcdn.ru/v1/SEL_72086/prodLMS/files/share/image6_cF9IOi7.png)

Возможно, вы уже увидели проблему, которая кроется в таком подходе.
list_of_lists[0][0] = 10 — изменение во вложенном списке.
print(list_of_lists)
print(list_of_lists_2)
[[10, 2, 3], 4, [5, 6, 7]]
[[10, 2, 3], 4, [5, 6, 7]] — будут отражаться и в копии списка, так как копия имеет точно такие же ссылки, какие были в оригинале.
В итоге мы как будто получаем не полную копию, а только поверхностную копию списка.

Именно эту проблему решает функция deepcopy из модуля copy.

list_of_lists = [[1, 2, 3], 4, [5, 6, 7]]
list_of_lists_2 = copy.deepcopy(list_of_lists)
![](https://api.selcdn.ru/v1/SEL_72086/prodLMS/files/share/image7_1yz6vvU.png)

list_of_lists[0][0] = 10
print(list_of_lists)
print(list_of_lists_2)
[[10, 2, 3], 4, [5, 6, 7]]
[[1, 2, 3], 4, [5, 6, 7]] — теперь изменения не отражаются в копии.

Deepcopy, по сути, рекурсивно прошла по всем вложенным спискам и к каждому применила copy(), создав копии всех вложенных объектов.

