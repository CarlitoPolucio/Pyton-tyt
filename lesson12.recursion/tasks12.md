## t1 Rec fac
Напишите рекурсивную функцию, считающая факториал натурального числа n

## t2 Rec pow 
Напишите рекурсивную функцию, возводящую число в степень n.

## t3 Links
```python
import random
 
def change_dict(dct):
    num = random.randint(1, 100)
    for i_key, i_value in dct.items():
        if isinstance(i_value, list):
            i_value.append(num)
        if isinstance(i_value, dict):
            i_value[num] = i_key
        if isinstance(i_value, set):
            i_value.add(num)
 
 
nums_list = [1, 2, 3]
some_dict = {1: 'text', 2: 'another text'}
uniq_nums = {1, 2, 3}
common_dict = {1: nums_list, 2: some_dict, 3: uniq_nums, 4: (10, 20, 30)}
 
change_dict(common_dict)
print(common_dict)
```

Сделайте так, чтобы nums_list, some_dict и uniq_nums не менялись после обработки их обработки функцией change_dict

## t4 Get meta
Напишите функцию, которая выводит на экран тип объекта аргумента, информацию о его изменяемости, а также id этого объекта.

## t5 Rec nums
Выведите числа от 1 до 10, используя рекурсивную функцию

## t6 Advanced sum
Напишите свою функцию sum_, которая должна быть более гибкой, чем стандартная. Она должна уметь складывать числа:

- из списка списков,
- набора параметров.

## t7 Search value by key*
Напишите рекурсивную функцию, которая находит заданный пользователем ключ в словаре и выдаёт значение этого ключа на экран.

Если пользователь хочет, то может ввести максимальную глубину — уровень, до которого будет просматриваться структура. 
```python
site = {
    'html': {
        'head': {
            'title': 'Мой сайт'
        },
        'body': {
            'h2': 'Здесь будет мой заголовок',
            'div': 'Тут, наверное, какой-то блок',
            'p': 'А вот здесь новый абзац'
        }
    }
}
```

## t8 Rec comprehension*
Вы уже работали с многомерными списками и решали задачи, где с помощью list comprehensions «выпрямляли» многомерные списки в один. Это не получится, если списков неограниченное количество и у элементов разные уровни вложенности.

```python
nice_list = [1, 2, [3, 4], [[5, 6, 7], [8, 9, 10]], [[11, 12, 13], [14, 15], [16, 17, 18]]]
```

Напишите рекурсивную функцию, которая раскрывает все вложенные списки, то есть оставляет только внешний список.
Функция должна получать список и возвращать его раскрытую версию (не нужно добавлять элементы в список, записанный в глобальную переменную, созданную снаружи функции).

## t9 Quick sort*
Реализуйте рекурсивный алгоритм быстрой сортировки (её называют сортировкой Хоара). 

1. Выберите один элемент списка (его иногда называют опорным элементом). Сделать это можно разными способами, но важно придерживаться одного принципа. В нашем случае опорным элементом всегда будет крайний правый (например, в списке [1, 2, 3] это 3).
2. Разбейте текущий список на три части: элементы меньше опорного, равные опорному и больше опорного. 
3. В списке [5, 8, 9, 4, 2, 9, 1, 8] опорным элементом будет число 8 (крайнее правое), а получить надо три списка:
  - [5, 4, 2, 1];
  - [8, 8];
  - [9, 9].
4. Для списка с элементами меньше опорного ([5, 4, 2, 1]) и списка с элементами больше опорного ([9, 9]) выполните те же шаги заново — запустите рекурсию.
   - результат_1 = рекурсия([5, 4, 2, 1]).
   - результат_2 = [8, 8].
   - результат_3 = рекурсия([9, 9]).
5. Сложите результаты вызова рекурсий и получите отсортированный список: отсортированный_список = результат_1 + результат_2 + результат_3.

## t10 Rec binary search**
Реализуйте рекурсивный алгоритм бинарного поиска

## t11 Rec Fib***
Реализуйте рекурсивный алгоритм подсчёта суммы последовательности Фибоначчи из n слагаемых. Функция принимает n, возвращает сумму.

Справка:

В последовательности Фибоначчи первые два числа равны 0 и 1, а каждое последующее число равно сумме двух предыдущих чисел.

```text
0, 1, 1, 2, 3, 5, 8, 13, 21,
```


