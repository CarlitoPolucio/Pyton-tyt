# Структуры данных

## Понятие изменяемых/неизменяемых объектов(mutable/immutable)*
В Python объекты делятся на изменяемые (mutable) и неизменяемые (immutable). Это важное различие, которое влияет на поведение объектов при их использовании, передаче в функции и копировании.

### Неизменяемые (Immutable) объекты

Неизменяемые объекты — это объекты, которые не могут быть изменены после создания. Если вы попытаетесь изменить такой объект, Python создаст новый объект с изменёнными данными.
Примеры неизменяемых типов: int, float, bool, str, tuple

```python
# Пример с числами
x = 10
y = x  # y ссылается на тот же объект, что и x
y = y + 5  # Создаётся новый объект для y
print(x)  # 10 (x не изменился)
print(y)  # 15

# Пример со строками
text = "hello"

# Попытка изменить первую букву объекта типа str
text[0] = "H"  # Ошибка! Строки неизменяемы
```

### Изменяемые (Mutable) объекты
Изменяемые объекты — это объекты, которые могут быть изменены после создания. Изменения происходят "на месте", без создания нового объекта.

Примеры изменяемых типов: list, dict, set

```python
# Пример со списком
my_list = [1, 2, 3]
my_list[0] = 99  # Изменение элемента списка
print(my_list)  # [99, 2, 3]
```

### Пример в рамках работы с функциями
- Неизменяемые объекты передаются по значению (создаётся копия).
- Изменяемые объекты передаются по ссылке (изменения внутри функции влияют на оригинал)

```python
def modify_immutable(x):
    x = x + 1  # Создаётся новый объект
    print("Inside function:", x)

def modify_mutable(lst):
    lst.append(99)  # Изменение оригинального списка
    print("Inside function:", lst)

# Пример с неизменяемым объектом
num = 10
modify_immutable(num)
print("Outside function:", num)  # 10 (не изменился)

# Пример с изменяемым объектом
my_list = [1, 2, 3]
modify_mutable(my_list)
print("Outside function:", my_list)  # [1, 2, 3, 99] (изменился)
```

### Пример в рамках копирование объектов*
- Для неизменяемых объектов копирование не требуется (они не изменяются).
- Для изменяемых объектов может потребоваться копировать элемент. Для копирования вложенных структур может потребоваться рекурсивное копирование

```python
import copy

# Поверхностное копирование (подходит для неизменяемых объектов)
original_list = [1, 2, 3]
# Применение метода списков copy для создания копии нового объекта в памяти на основе исходного списка
shallow_copy = original_list.copy()
shallow_copy[0] = 99
print(original_list)  # [1, 2, 3] (не изменился)

# Рекурсивное копирование (для вложенных изменяемых объектов)
nested_list = [[1, 2], [3, 4]]
deep_copy = copy.deepcopy(nested_list)
deep_copy[0][0] = 99
print(nested_list)  # [[1, 2], [3, 4]] (не изменился)
```

## Списки в python
В Python списки (lists) — это один из самых универсальных и часто используемых типов данных. Они представляют собой упорядоченные коллекции элементов, которые могут быть любого типа (числа, строки, другие списки и т.д.).

```python
# Создание пустого списка
empty_list = []

# Создание списка с элементами
fruits = ["apple", "banana", "cherry"]
numbers = [1, 2, 3, 4, 5]
mixed_list = [1, "apple", 3.14, True]
```

Элементы списка индексируются, начиная с 0. Можно использовать отрицательные индексы для доступа к элементам с конца списка.

```python
fruits = ["apple", "banana", "cherry"]

# Доступ к первому элементу
first_fruit = fruits[0]  # "apple"

# Доступ к последнему элементу
last_fruit = fruits[-1]  # "cherry"
```

Списки являются изменяемыми (mutable), поэтому их элементы можно изменять:
```python
fruits = ["apple", "banana", "cherry"]

# Изменение второго элемента
fruits[1] = "blueberry"
print(fruits)  # ["apple", "blueberry", "cherry"]
```

### Методы списков

#### Добавление объектов в список

```python
fruits = ["apple", "banana"]

# Добавление элемента в конец
fruits.append("cherry")
print(fruits)  # ["apple", "banana", "cherry"]

# Вставка элемента на позицию 1
fruits.insert(1, "blueberry")
print(fruits)  # ["apple", "blueberry", "banana", "cherry"]

# Добавление нескольких элементов через аргумент итерируемого объекта
fruits.extend(["orange", "grape"])
print(fruits)  # ["apple", "blueberry", "banana", "cherry", "orange", "grape"]
```

#### Удаление объектов из списка
```python
fruits = ["apple", "banana", "cherry", "banana"]

# Удаление элемента по значению
fruits.remove("banana")
print(fruits)  # ["apple", "cherry", "banana"]

# Удаление последнего элемента
fruits.pop()
print(fruits)  # ["apple", "cherry"]
```

#### Некоторые методы списков

```python
numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5]

# Длина списка
length = len(numbers)  # 9

# Сортировка списка
numbers.sort()
print(numbers)  # [1, 1, 2, 3, 4, 5, 5, 6, 9]

# Разворот списка
numbers.reverse()
print(numbers)  # [9, 6, 5, 5, 4, 3, 2, 1, 1]

# Индекс элемента
index = numbers.index(5)  # 2

# Количество вхождений элемента
count = numbers.count(1)  # 2
```

### List comprehensions (представление списков)
List comprehensions - способ создания списков. Такие списки целиком помещаются в оперативную память в момент завершения генерации.

```python
# Создание списка квадратов чисел от 0 до 9
squares = [x ** 2 for x in range(10)]
print(squares)  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# Создание списка чётных чисел
evens = [x for x in range(10) if x % 2 == 0]
print(evens)  # [0, 2, 4, 6, 8]
```

### Вложенные списки
Поскольку списки тоже объекты, никто не запрещает хранить в качестве элемента списка другой список.

```python
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

# Доступ к элементу вложенного списка
element = matrix[1][2]  # 6
```

### Срезы списков
При применение среза под капотом происходит копирование объекта. Срезанный список является новым объектом в памяти.

Синтаксис среза [start=0:stop=значение длины списка:1]
```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# Срез с 2-го по 5-й элемент (индексы 2, 3, 4)
slice_1 = numbers[2:5]  # [2, 3, 4]

# Срез с начала до 5-го элемента
slice_2 = numbers[:5]  # [0, 1, 2, 3, 4]

# Срез с 5-го элемента до конца
slice_3 = numbers[5:]  # [5, 6, 7, 8, 9]

# Срез с шагом 2
slice_4 = numbers[::2]  # [0, 2, 4, 6, 8]

# Срез с отрицательным шагом
slice_5 = numbers[5:3:-1]  # [5, 4]

# Аналог реверса
slice_6 = numbers[::-1] # [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]

# Копирование исходного списка с помощью среза
new_list = numbers[:]
```

## Понятие *массив* в it
Массив — это структура данных, которая представляет собой упорядоченную коллекцию элементов одного типа. Элементы массива хранятся в памяти последовательно, и доступ к ним осуществляется по индексу. Массивы широко используются в программировании для хранения и обработки данных.

- Все элементы массива имеют одинаковый тип данных (например, целые числа, строки и т.д.).
- Размер массива обычно задаётся при его создании и не может быть изменён.
- Элементы массива доступны по индексу (начинается с 0 или 1, в зависимости от языка).
- Элементы массива хранятся в памяти последовательно, что обеспечивает быстрый доступ к ним.


В Python массивы реализованы как списки (list), но они могут содержать элементы разных типов и имеют динамический размер


## Строки*
Строки в Python — это неизменяемые (immutable) объекты, представляющие собой последовательность символов.

### Срезы строк
```python
text = "Python"
print(text[1:4])  # 'yth' (срез с 1 по 3 индекс)
print(text[:3])   # 'Pyt' (срез с начала до 3 индекса)
print(text[3:])   # 'hon' (срез с 3 индекса до конца)
print(text[::-1]) # 'nohtyP' (обратная строка)
```

### Некоторые методы строк

#### Поиск и замена
- find(sub) Возвращает индекс первого вхождения подстроки sub (или -1, если подстрока не найдена).
- replace(old, new) Заменяет все вхождения подстроки old на new.
```python
text = "Hello, World!"
print(text.find("World"))  # 7
print(text.replace("World", "Python"))  # "Hello, Python!"
```

#### Разделение и объединение
- split(sep) Разделяет строку на список подстрок по разделителю sep.
- join(iterable) Объединяет элементы итерируемого объекта в строку.
```python
text = "apple,banana,cherry"
fruits = text.split(",")  # ["apple", "banana", "cherry"]
new_text = "-".join(fruits)  # "apple-banana-cherry"
```

#### Регистр символов
- upper() Преобразует строку в верхний регистр.
- lower() Преобразует строку в нижний регистр.
- title() Преобразует строку в формат заголовка.

```python
text = "hello, world!"
print(text.upper())  # "HELLO, WORLD!"
print(text.lower())  # "hello, world!"
print(text.title())  # "Hello, World!"
```

#### Проверка содержимого
- startswith(prefix) Проверяет, начинается ли строка с prefix.
- endswith(suffix) Проверяет, заканчивается ли строка на suffix.
- isalpha() Проверяет, состоит ли строка только из букв.
- isdigit() Проверяет, состоит ли строка только из цифр.

```python
text = "Python123"
print(text.startswith("Py"))  # True
print(text.endswith("123"))   # True
print(text.isalpha())         # False (содержит цифры)
```

#### Способы форматирования

##### format

```python
name = "Bob"
age = 30
text = "My name is {} and I am {} years old.".format(name, age)
print(text)  # "My name is Bob and I am 30 years old."
```

##### %
```python
name = "Charlie"
age = 35
text = "My name is %s and I am %d years old." % (name, age)
print(text)  # "My name is Charlie and I am 35 years old."
```

#### Дандер* методы
```python
text = "Python"
print(len(text))  # 6
print("th" in text)  # True
```

